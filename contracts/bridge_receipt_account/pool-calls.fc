#include "../common/stdlib.fc";
#include "../common/dic.fc";
#include "../common/message.fc";
#include "../common/utils.fc";
#include "../common/stdlib.fc";
#include "op.fc";
#include "storage.fc";
#include "errors.fc";
#include "../gas.fc";

() handle_pool_messages(int op, int query_id, int my_balance, int msg_value, slice in_msg_body) impure inline {
    if (op == record_receipt) {
        (var target_chain_id, var target_address, var jetton_amount) = (in_msg_body~load_uint(32), in_msg_body~load_bits(256), in_msg_body~load_coins());
        (var receipt_info, var found) = storage::receipt_info_dic.udict_get?(CHAIN_ID_KEY_LENGTH, target_chain_id);
        var index_value = 0;
        if (found) {
            var total_amount = receipt_info~load_uint(256);
            var index = receipt_info~load_uint(256);
            total_amount += jetton_amount;
            index += 1;
            index_value = index;
            storage::receipt_info_dic~udict_set_builder(CHAIN_ID_KEY_LENGTH,
                target_chain_id,
                begin_cell().store_uint(total_amount, 256).store_uint(index, 256));
        } else {
            storage::receipt_info_dic~udict_set_builder(CHAIN_ID_KEY_LENGTH,
                target_chain_id,
                begin_cell().store_uint(jetton_amount, 256).store_uint(1, 256));
            index_value = 1;
        }
        save_storage();
        (int wc, int address_hash) = parse_std_addr(storage::jetton_address);
        (int wc, int my_address_hash) = parse_std_addr(my_address());
        var token_key = begin_cell()
            .store_uint(WORKCHAIN, 32)
            .store_uint(my_address_hash, 256)
            .store_uint(target_chain_id, 32)
            .store_uint(address_hash, 256).end_cell();
        int key_hash = string_hash(token_key.begin_parse());
        var receipt_id = begin_cell()
            .store_uint(key_hash, 256)
            .store_uint(index_value, 256)
            .end_cell();

        var body = begin_cell()
            .store_uint(receipt_ok, 32)
            .store_uint(query_id, 64)
            .store_uint(target_chain_id, 32)
            .store_coins(jetton_amount)
            .store_ref(begin_cell()
                .store_slice(storage::owner)
                .store_slice(storage::jetton_address)
                .store_slice(target_address)
                .end_cell())
            .store_ref(receipt_id)
            .end_cell();
        int to_leave_on_balance = my_balance - msg_value + my_storage_due();
        int amount = max(to_leave_on_balance, calculate_bridge_receipt_account_min_storage_fee());
        raw_reserve(amount, RESERVE_AT_MOST);
        send_simple_message(0, storage::bridge_address, body, SEND_MODE_CARRY_ALL_BALANCE);
        return ();
    }

    throw(WRONG_OP);
}
