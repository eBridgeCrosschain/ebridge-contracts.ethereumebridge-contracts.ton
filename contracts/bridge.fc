#include "bridge/storage.fc";
#include "bridge/op.fc";
#include "bridge/errors.fc";
#include "bridge/getter.fc";
#include "bridge/admin-calls.fc";
#include "bridge/owner-calls.fc";
#include "bridge/bridge_receipt_account-utils.fc";
#include "bridge/oracle.fc";
#include "bridge/transfer-notification-calls.fc";
#include "bridge/params.fc";
#include "bridge/get.fc";
#include "common/dic.fc";
#include "common/message.fc";
#include "common/jetton-utils.fc";
#include "common/stdlib.fc";
#include "common/utils.fc";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        ;; ignore empty messages
        return ();
    }
    var cs = in_msg_full.begin_parse();
    var flags = cs~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool

    slice sender_address = cs~load_msg_addr();

    load_storage();

    if (flags & 1) {
        ;; ignore bounce message
        return ();
    }
    cs~load_msg_addr(); ;; skip dst
    cs~load_coins(); ;; skip value
    cs~skip_bits(1); ;; skip extracurrency collection
    cs~load_coins(); ;; skip ihr_fee
    int fwd_fee = cs~load_coins();

    force_chain(WORKCHAIN, sender_address, WRONG_WORKCHAIN);
    (int op, int query_id) = (in_msg_body~load_uint(32), in_msg_body~load_uint(64));

    if (op == transfer_notification) {
        (int jetton_amount, slice from_sender) = (in_msg_body~load_coins(), in_msg_body~load_msg_addr());
        cell ref_cs = in_msg_body~load_ref();
        handle_transfer_notification(sender_address, query_id, jetton_amount, from_sender, ref_cs, fwd_fee);
        return ();
    }

    if (op == create_native_receipt) {
        (int target_chain_id, slice target_address, int amount) = (in_msg_body~load_uint(32), in_msg_body~load_bits(256), in_msg_body~load_coins());
        (var jetton_pool_address, _) = dict_get?(storage::bridge_pool_address_dic, KEY_LENGTH, HOLE_ADDRESS);
        var body = begin_cell()
            .store_uint(lock_native_token, 32)
            .store_uint(target_chain_id, 32)
            .store_slice(target_address)
            .store_slice(sender_address)
            .store_coins(amount)
            .end_cell();
        send_simple_message(amount, jetton_pool_address, body, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE + SEND_MODE_BOUNCE_TRANSACTION);

    }
    if (op == receipt_ok) {
        slice jetton_address = in_msg_body~load_msg_addr();
        slice owner_address = in_msg_body~load_msg_addr();
        int target_chain_id = in_msg_body~load_uint(32);
        slice target_address = in_msg_body~load_bits(256);
        int jetton_amount = in_msg_body~load_coins();
        cell receipt_id = in_msg_body~load_ref();
        (var jetton_pool_address, _) = dict_get?(storage::bridge_pool_address_dic, KEY_LENGTH, jetton_address);
        cell acc_state_init = calculate_bridge_receipt_account_state_init(owner_address, jetton_pool_address, jetton_address, my_address(), storage::bridge_receipt_account_code);
        throw_unless(UNAUTHORIZED, equal_slices(sender_address, calculate_bridge_receipt_account_address(acc_state_init)));
        emit_log_simple(NEW_RECEIPT, begin_cell()
            .store_slice(owner_address)
            .store_uint(target_chain_id, 32)
            .store_slice(target_address)
            .store_slice(jetton_address)
            .store_coins(jetton_amount)
            .store_ref(receipt_id)
            .end_cell(),
            1
        );

    }
    if (op == transmit) {
        ;; Handler oracle call
        throw_unless(UNAUTHORIZED, equal_slices(sender_address, storage::oracle_address));
        var message_id = in_msg_body~load_int(256);
        if (storage::is_pause) {
            resend_receipt_info(message_id, ONEDAY);
        }
        var origin_data = in_msg_body~load_ref();
        var data = origin_data.begin_parse();
        var source_chain_id = data~load_int(32);
        var target_chain_id = data~load_int(32);
        var sender = data~load_ref().begin_parse();
        var receiver = data~load_ref().begin_parse();
        var message = data~load_ref().begin_parse();
        var receipt_index = message~load_uint(256);
        var receipt_hash = message~load_bits(256);
        var receipt_amount = message~load_uint(256);
        (slice target_contract,_) = storage::target_contract_dic.udict_get?(CHAIN_ID_KEY_LENGTH,source_chain_id);
        throw_unless(INVALID_SOURCE_CHAIN_CONTRACT, equal_slices(sender, target_contract));
        throw_unless(INVALID_AMOUNT, receipt_amount > 0);
        var receipt_target_address = message~load_bits(256);
        var receipt_id_token = message~load_bits(256);
        cell receipt_index_cell = begin_cell().store_uint(receipt_index, 256).end_cell();
        var receipt_index_hash = string_hash(receipt_index_cell.begin_parse());
        var receipt_id_token_hash = string_hash(receipt_id_token);
        cell receipt_amount_cell = begin_cell().store_uint(receipt_amount, 256).end_cell();
        var receipt_amount_hash = string_hash(receipt_amount_cell.begin_parse());
        var receipt_target_address_hash = string_hash(receipt_target_address);
        cell leaf_cell = begin_cell()
            .store_uint(receipt_index_hash, 256)
            .store_uint(receipt_id_token_hash, 256)
            .store_uint(receipt_amount_hash, 256)
            .store_uint(receipt_target_address_hash, 256)
            .end_cell();
        var leaf_hash = string_hash(leaf_cell.begin_parse());
        throw_unless(VERIFICATION_FAILED, leaf_hash == receipt_hash~load_uint(256));
        cell convert_info = data~load_ref();
        slice info = convert_info.begin_parse();
        cell jetton_address_cell = info~load_ref();
        slice jetton_address = jetton_address_cell.begin_parse();
        var swap_id = info~load_ref();
        (var jetton_swap_address, int found_swap) = dict_get?(storage::bridge_swap_address_dic, KEY_LENGTH, jetton_address);
        if (~ found_swap) {
            throw(NOT_FOUND_SWAP);
        }
        var payload = begin_cell()
            .store_uint(swap, 32)
            .store_uint(query_id, 64)
            .store_ref(swap_id)
            .store_uint(message_id, 256)
            .store_ref(begin_cell()
                .store_slice(receipt_hash)
                .store_slice(receipt_target_address)
                .end_cell())
            .store_uint(receipt_amount, 256)
            .end_cell();
        send_simple_message(0, jetton_swap_address, payload, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);
    }

    if (op == resend_to_oracle) {
        var jetton_address = in_msg_body~load_msg_addr();
        (var jetton_swap_address, int found_swap) = dict_get?(storage::bridge_swap_address_dic, KEY_LENGTH, jetton_address);
        throw_unless(UNAUTHORIZED, found_swap & equal_slices(sender_address, jetton_swap_address));
        (var message_id, var time_span) = (in_msg_body~load_uint(256), in_msg_body~load_uint(64));
        resend_receipt_info(message_id, time_span);
    }
    ;; handle governance message from admin to change pool parameters
    if (equal_slices(sender_address, storage::owner)) {
        handle_owner_messages(op, query_id, my_balance, msg_value, in_msg_body);
        return ();
    }
    if (equal_slices(sender_address, storage::admin)) {
        handle_admin_messages(op, query_id, my_balance, msg_value, in_msg_body);
        return ();
    }
    ;; make sure that the message has been processed
    if (handle_getter_messages(op, query_id, sender_address, in_msg_body)) {
        return ();
    }

    if (op == pause) {
        throw_unless(UNAUTHORIZED, equal_slices(sender_address, storage::pause_controller));
        storage::is_pause = true;
        save_storage();
        emit_log_simple(PAUSED,
            begin_cell()
                .store_uint(now(), 64)
                .end_cell(),
            1
        );
    }

    throw(WRONG_OP);
}


