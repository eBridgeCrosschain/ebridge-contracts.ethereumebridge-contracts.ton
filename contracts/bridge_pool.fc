#include "common/stdlib.fc";
#include "common/jetton-utils.fc";
#include "common/message.fc";
#include "common/dic.fc";
#include "common/utils.fc";
#include "bridge_pool/storage.fc";
#include "bridge_pool/op.fc";
#include "bridge_pool/errors.fc";
#include "bridge_pool/getter.fc";
#include "bridge_pool/admin-calls.fc";
#include "bridge_pool/owner-calls.fc";
#include "bridge_pool/bridge_receipt_account-utils.fc";
#include "bridge_pool/limiter.fc";
#include "bridge_pool/bridge_pool_liquidity_account-utils.fc";
#include "bridge_pool/get.fc";


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        ;; ignore empty messages
        return ();
    }
    var cs = in_msg_full.begin_parse();
    var flags = cs~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool

    slice sender_address = cs~load_msg_addr();

    load_storage();

    if (flags & 1) {
        return ();
    }
    cs~load_msg_addr(); ;; skip dst
    cs~load_coins(); ;; skip value
    cs~skip_bits(1); ;; skip extracurrency collection
    cs~load_coins(); ;; skip ihr_fee
    int fwd_fee = cs~load_coins();

    force_chain(WORKCHAIN, sender_address, WRONG_WORKCHAIN);
    (int op, int query_id) = (in_msg_body~load_uint(32), in_msg_body~load_uint(64));

    if (op == transfer_notification) {
        (int jetton_amount, slice from_sender) = (in_msg_body~load_coins(), in_msg_body~load_msg_addr());
        cell ref_cs = in_msg_body~load_ref();
        slice ref_ds = ref_cs.begin_parse();

        throw_unless(INVALID_AMOUNT, jetton_amount > 0);
        int transfer_op = ref_ds~load_uint(32);

        if (transfer_op == lock) {
            throw_unless(UNAUTHORIZED, equal_slices(from_sender, storage::bridge_address));
            (int target_chain_id, slice target_address, slice owner) = (ref_ds~load_uint(32), ref_ds~load_bits(256), ref_ds~load_msg_addr());
            (var success, var error, var min_wait_seconds) = consume_limit(target_chain_id, RECEIPT, jetton_amount);
            if (success) {
                storage::liquidity += jetton_amount;
                cell acc_state_init = calculate_bridge_receipt_account_state_init(owner, my_address(), storage::jetton_address, storage::bridge_address, storage::bridge_receipt_account_code);
                var body = begin_cell()
                    .store_uint(record_receipt, 32)
                    .store_uint(query_id, 64)
                    .store_uint(target_chain_id, 32)
                    .store_slice(target_address)
                    .store_coins(jetton_amount);
                send_message_with_stateinit(0, calculate_bridge_receipt_account_address(acc_state_init), acc_state_init, body.end_cell(), SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE + SEND_MODE_IGNORE_ERRORS);
                emit_log_simple(LOCKED,
                    begin_cell()
                        .store_slice(owner)
                        .store_slice(storage::jetton_address)
                        .store_coins(jetton_amount)
                        .store_uint(target_chain_id, 32)
                        .store_slice(target_address)
                        .end_cell(),
                    1);
            } else {
                var body = create_simple_transfer_body(query_id, 0, jetton_amount, owner);
                body = body.store_uint(error, 32);
                if (min_wait_seconds > 0) {
                    body.store_uint(min_wait_seconds, 64);
                } else {
                    body.store_uint(0, 64);
                }
                send_simple_message(0, owner, body.end_cell(), SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);
            }
            save_storage();
        }

        if (transfer_op == add_liquidity) {
            storage::liquidity += jetton_amount;
            cell acc_state_init = calculate_bridge_pool_liquidity_account_state_init(from_sender, my_address(), storage::jetton_address, storage::pool_liquidity_account_code);
            var body = begin_cell()
                .store_uint(provider_liquidity, 32)
                .store_uint(query_id, 64)
                .store_coins(jetton_amount);
            send_message_with_stateinit(0, calculate_bridge_pool_liquidity_account_address(acc_state_init), acc_state_init, body.end_cell(), SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE + SEND_MODE_IGNORE_ERRORS);
            save_storage();
        }
        return ();
    }

    if (op == lock_native_token) {
        throw_unless(UNAUTHORIZED, equal_slices(sender_address, storage::bridge_address));
        (var target_chain_id, slice target_address, var owner, var lock_ton_amount) = (in_msg_body~load_uint(32), in_msg_body~load_bits(256), in_msg_body~load_msg_addr(), in_msg_body~load_coins());
        throw_unless(INVALID_AMOUNT, msg_value - fwd_fee > lock_ton_amount);
        (var success, var error, var min_wait_seconds) = consume_limit(target_chain_id, RECEIPT, lock_ton_amount);
        if (success) {
            storage::liquidity += lock_ton_amount;
            cell acc_state_init = calculate_bridge_receipt_account_state_init(owner, my_address(), storage::jetton_address, storage::bridge_address, storage::bridge_receipt_account_code);
            var body = begin_cell()
                .store_uint(record_receipt, 32)
                .store_uint(query_id, 64)
                .store_uint(target_chain_id, 32)
                .store_slice(target_address)
                .store_coins(lock_ton_amount);
            send_message_with_stateinit(0, calculate_bridge_receipt_account_address(acc_state_init), acc_state_init, body.end_cell(), SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE + SEND_MODE_IGNORE_ERRORS);
            emit_log_simple(LOCKED,
                begin_cell()
                    .store_slice(owner)
                    .store_slice(storage::jetton_address)
                    .store_coins(lock_ton_amount)
                    .store_uint(target_chain_id, 32)
                    .store_slice(target_address)
                    .end_cell(),
                1);
        } else {
            throw(error);
        }

    }
    if (op == release) {
        (var swap_id, var message_id, var receipt_hash, var chain_id, var receiver, var amount) = (in_msg_body~load_ref(), in_msg_body~load_uint(256), in_msg_body~load_bits(256), in_msg_body~load_uint(32), in_msg_body~load_msg_addr(), in_msg_body~load_coins());
        if (storage::liquidity < amount) {
            var body = begin_cell()
                .store_uint(swap_failed, 32)
                .store_uint(query_id, 64)
                .store_slice(receipt_hash)
                .store_uint(message_id, 256)
                .store_uint(LIQUIDITY_NOT_ENOUGH, 32)
                .store_uint(HALF_ONE_DAY, 64)
                .end_cell();
            send_simple_message(0, storage::bridge_swap_address, body, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE | SEND_MODE_IGNORE_ERRORS);
        }
        (var success, var error, var min_wait_seconds) = consume_limit(chain_id, SWAP, amount);
        if (success) {
            var ton_amount = (msg_value) / 2;
            var body0 = create_simple_transfer_body(query_id, 0, amount, receiver);
            body0 = body0.store_uint(swap_ok, 32);
            storage::liquidity -= amount;
            send_simple_message(ton_amount, storage::jetton_address, body0.end_cell(), SEND_MODE_REGULAR | SEND_MODE_IGNORE_ERRORS);
            emit_log_simple(RELEASED,
                begin_cell()
                    .store_slice(receiver)
                    .store_slice(storage::jetton_address)
                    .store_coins(amount)
                    .store_uint(chain_id, 256)
                    .end_cell(),
                1);
            var body_record_swap = begin_cell()
                .store_uint(record_swap, 32)
                .store_uint(query_id, 64)
                .store_ref(swap_id)
                .store_coins(amount)
                .end_cell();
            send_message_nobounce(ton_amount, storage::bridge_swap_address, body_record_swap, SEND_MODE_REGULAR | SEND_MODE_IGNORE_ERRORS);
        } else {
            var body1 = begin_cell()
                .store_uint(swap_failed, 32)
                .store_uint(query_id, 64)
                .store_slice(receipt_hash)
                .store_uint(message_id, 256)
                .store_uint(error, 32)
                .store_uint(min_wait_seconds, 64)
                .end_cell();
            send_simple_message(0, storage::bridge_swap_address, body1, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE | SEND_MODE_IGNORE_ERRORS);
        }
        save_storage();
    }

    if (op == release_native_token) {
        (var swap_id, var message_id, var receipt_hash, var chain_id, var receiver, var amount) = (in_msg_body~load_ref(), in_msg_body~load_uint(256), in_msg_body~load_bits(256), in_msg_body~load_uint(32), in_msg_body~load_msg_addr(), in_msg_body~load_coins());
        if ((msg_value < amount) | (storage::liquidity < amount)) {
            var body = begin_cell()
                .store_uint(swap_failed, 32)
                .store_uint(query_id, 64)
                .store_slice(receipt_hash)
                .store_uint(message_id, 256)
                .store_uint(LIQUIDITY_NOT_ENOUGH, 32)
                .store_uint(HALF_ONE_DAY, 64)
                .end_cell();
            send_simple_message(0, storage::bridge_swap_address, body, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE | SEND_MODE_IGNORE_ERRORS);
        }
        (var success, var error, var min_wait_seconds) = consume_limit(chain_id, SWAP, amount);
        if (success) {
            int fee = 0;
            var body = begin_cell().store_uint(chain_id, 32).end_cell();
            storage::liquidity -= amount;
            send_simple_message(amount, receiver, body, SEND_MODE_REGULAR);
            emit_log_simple(RELEASED,
                begin_cell()
                    .store_slice(receiver)
                    .store_slice(storage::jetton_address)
                    .store_coins(amount)
                    .store_uint(chain_id, 256)
                    .end_cell(),
                1);
            var body_record_swap = begin_cell()
                .store_uint(record_swap, 32)
                .store_uint(query_id, 64)
                .store_ref(swap_id)
                .store_coins(amount)
                .end_cell();
            send_message_nobounce(0, storage::bridge_swap_address, body_record_swap, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE | SEND_MODE_IGNORE_ERRORS);
        } else {
            var body1 = begin_cell()
                .store_uint(swap_failed, 32)
                .store_uint(query_id, 64)
                .store_slice(receipt_hash)
                .store_uint(message_id, 256)
                .store_uint(error, 32)
                .store_uint(min_wait_seconds, 64)
                .end_cell();
            send_simple_message(0, storage::bridge_swap_address, body1, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE | SEND_MODE_IGNORE_ERRORS);
        }
        save_storage();
    }

    if (op == add_native_token_liquidity) {
        int amount = in_msg_body~load_coins();
        storage::liquidity += amount;
        msg_value -= amount;
        cell acc_state_init = calculate_bridge_pool_liquidity_account_state_init(sender_address, my_address(), storage::jetton_address, storage::pool_liquidity_account_code);
        var body = begin_cell()
            .store_uint(provider_liquidity, 32)
            .store_uint(query_id, 64)
            .store_coins(amount);
        send_message_with_stateinit(0, calculate_bridge_pool_liquidity_account_address(acc_state_init), acc_state_init, body.end_cell(), SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE | SEND_MODE_IGNORE_ERRORS);
        save_storage();
    }

    if (op == remove_liquidity) {
        var liquidity = in_msg_body~load_coins();
        slice owner = in_msg_body~load_msg_addr();
        cell acc_state_init = calculate_bridge_pool_liquidity_account_state_init(owner, my_address(), storage::jetton_address, storage::pool_liquidity_account_code);
        throw_unless(UNAUTHORIZED, equal_slices(calculate_bridge_pool_liquidity_account_address(acc_state_init), sender_address));
        throw_unless(LIQUIDITY_NOT_ENOUGH, storage::liquidity >= liquidity);
        storage::liquidity -= liquidity;
        var body0 = create_simple_transfer_body(query_id, 0, liquidity, owner);
        body0 = body0.store_uint(REMOVE_LIQUIDITY_OK, 32); ;; append exit code
        send_simple_message(0, storage::jetton_address, body0.end_cell(), SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE | SEND_MODE_IGNORE_ERRORS);
        save_storage();
    }


    if (op == remove_native_token_liquidity) {
        var liquidity = in_msg_body~load_coins();
        slice owner = in_msg_body~load_msg_addr();
        cell acc_state_init = calculate_bridge_pool_liquidity_account_state_init(owner, my_address(), storage::jetton_address, storage::pool_liquidity_account_code);
        throw_unless(UNAUTHORIZED, equal_slices(calculate_bridge_pool_liquidity_account_address(acc_state_init), sender_address));
        throw_unless(LIQUIDITY_NOT_ENOUGH, storage::liquidity >= liquidity);
        storage::liquidity -= liquidity;
        send_simple_message(liquidity, owner, begin_cell().store_slice(owner).end_cell(), SEND_MODE_REGULAR);
        save_storage();
    }
    
    if (equal_slices(sender_address, storage::owner)) {
        handle_owner_messages(op, query_id, my_balance, msg_value, in_msg_body);
        return ();
    }
    ;; handle governance message from admin to change pool parameters
    if (equal_slices(sender_address, storage::admin)) {
        handle_admin_messages(op, query_id, my_balance, msg_value, in_msg_body);
        return ();
    }

    ;; make sure that the message has been processed
    if (handle_getter_messages(op, query_id, sender_address, in_msg_body)) {
        return ();
    }

    throw(WRONG_OP);
}
